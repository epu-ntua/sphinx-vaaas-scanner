import os
import re
import threading
from datetime import datetime
from functools import partial

from libnmap.parser import NmapParser
from libnmap.process import NmapProcess, NmapTask
from libnmap.reportjson import ReportEncoder
from libnmap.objects import NmapReport
from redis_manager.manager import *
from report_parser.nmap_report_parser import ReportParser
from utils.utils import *

log = get_main_logger('vaaas_scanner')

scan_task = {'name': '',
             'processes':
                 {
                     '<running_process>': {'status': '', 'etc': '', 'progress': '', 'remaining': ''}
                 },
             'reports': ''
             }


# class VaaasRunner(threading.Thread):
#     def __init__(self, function_that_runs):
#         threading.Thread.__init__(self)
#         self.runnable = function_that_runs
#
#     def run(self):
#         self.runnable()


def write_report_to_file(report_str: str):
    with open(os.path.join(os.path.split(os.path.abspath(__file__))[0], f"{datetime.now():%Y-%m-%d_%H-%M}" + '.json'), 'w') as f:
        f.write(report_str)


class Vaaas:
    def __init__(self):
        self.vulners_url = 'vulners'
        self.vulscan_url = 'vulscan'
        # self.map = nmap3.Nmap()

    @staticmethod
    def get_now() -> str:
        return str(re.sub('[^0-9a-zA-Z]+', '_', datetime.now().strftime("%m/%d/%Y_%H:%M:%S")))

    @staticmethod
    def get_timestamp() -> str:
        return str(int(datetime.now().timestamp()))

    @staticmethod
    def get_task_name(_name: str) -> str:
        return str(re.sub('[^0-9a-zA-Z]+', '_', _name))

    def scan_network(self, _name, _net, speed: int = 3, script='') -> dict:
        # print(_net, speed)
        try:
            # if not self.is_task_running(_net):
            # thread = threading.Thread(target=self.run_scan, args=(_name, _net, speed, script))
            # thread.start()
            self.run_scan(_name=_name, _net=_net, speed=speed, script=script)
            return create_result(result_=func_name() + '_STARTED', more=f'Started assessment for {_net}')
            # else:
            #     return create_result(result_=func_name() + '_FAILURE', more='Task already running')
        except Exception as e:
            log.error(dmsg('') + func_name() + '_FAILURE : ' + e.__str__())
            return create_result(result_=func_name() + '_FAILURE', more=e.__str__())

    # def get_report(self, report_key: str) -> dict:
    #     try:
    #         # print(get_data_by_wildcard(report_key))
    #         return create_result(result_='GET_REPORT_SUCCESS', items={'reports': get_data_by_wildcard(report_key)})
    #     except Exception as e:
    #         log.error(dmsg('') + 'GET_REPORT_FAILURE : ' + e.__str__())
    #         return create_result(result_='GET_REPORT_FAILURE', more=e.__str__())

    def run_scan(self, _name: str, _net: str, speed: int, script: str) -> None:
        try:
            # print(_net, speed)
            assert (speed in [1, 2, 3, 4, 5]), 'speed value should be between 1 and 5'
            # proc = NmapProcess(targets=_net, options=f"-sV --version-all --allports -A -T{str(speed)} {'--script ' + script if script else ''}",
            # proc = NmapProcess(targets=_net, options=f"-sV --version-all --allports -A -T{str(speed)} --script=nmap-vulners/vulners{',' + script if script else ''}",
            proc = NmapProcess(targets=_net,
                               options=f"-T{str(speed)} --script {script + ',' if script else ''}vuln -sV {' --script-args=checkall=1,safe=1' if script == 'p2p-conficker,smb-os-discovery,smb-vuln-conficker' else ''}",
                               # proc = NmapProcess(targets=_net, options=f"--script nmap-vulners/ -sV",
                               # proc = NmapProcess(targets=_net, options=f"-sV --version-all --allports -A -T{str(speed)} --script {script if script else 'nmap-vulners/vulners'}",
                               event_callback=partial(self.scan_progress, _name=_name, _net=_net, _speed=speed))
            assert proc.name, Exception('could not create can job')
            write_data(self.get_task_name(_name), {'name': self.get_task_name(_name), 'target': _net, 'speed': speed, 'processes': {}, 'reports': {}})
            proc.run()  # run the process
            print('finished scanning')
            nmap_report_object: NmapReport = NmapParser.parse(proc.stdout)
            print('--------------------------', nmap_report_object.get_dict())
            report = json.dumps(nmap_report_object, cls=ReportEncoder, indent=4) if nmap_report_object else ''
            # report = nmap_report_object.get_raw_data()
            print('----raw raw', nmap_report_object.get_raw_data())
            write_report_to_file(report_str=report) if report else None
            _data = get_data_by_key(self.get_task_name(_name))
            if _data:
                stix_report = ReportParser(json.loads(report)).get_stix_report()
                print(f'stix_report: {stix_report}')
                _data['reports'].update({self.get_timestamp(): stix_report}) if report else None
                print(dmsg('') + 'saved report')
                write_data(self.get_task_name(_name), _data) if report else None
            else:
                pass
            log.debug(dmsg('') + get_data_by_key(self.get_task_name(_name)))
        except Exception as e:
            log.error(dmsg('') + e.__str__())

    def scan_progress(self, _proc: NmapProcess, _name: str, _net: str, _speed: int) -> None:
        try:
            _task: NmapTask = _proc.current_task
            if _task:
                _data = get_data_by_key(self.get_task_name(_name))
                if _data:
                    _data['target'] = _net
                    _data['processes'].update({_task.name: {'status': _task.status, 'etc': _task.etc, 'progress': _task.progress, 'remaining': _task.remaining}})
                else:
                    _data = {
                        'name': self.get_task_name(_name),
                        'target': _net,
                        'processes': {_task.name: {'status': _task.status, 'etc': _task.etc, 'progress': _task.progress, 'remaining': _task.remaining}},
                        'reports': {}
                    }
                write_data(self.get_task_name(_name), _data)
                log.debug(f"task_name: {_task.name} -> 'status': {_task.status}, 'etc': {_task.etc}, 'progress': {_task.progress}, 'remaining': {_task.remaining}")
                # log.debug(get_data_by_key(self.get_task_name(_name)))
                print(f"task_name: {_task.name} - net: {_net} -> 'status': {_task.status}, 'etc': {_task.etc}, 'progress': {_task.progress}, 'remaining': {_task.remaining}")
            else:
                pass
        except Exception as e:
            log.error(dmsg('') + e.__str__())

    def get_task_reports(self, _net: str) -> dict:
        try:
            _data = get_data_by_key(self.get_task_name(_net))
            # print(_data['reports'])
            output = {_net: [{k: ReportParser(_data['reports'][k]).get_stix_report() for k in _data['reports'].keys()}]}
            return create_result(result_=func_name() + '_SUCCESS', items={'reports': output if _data else {}})
        except Exception as e:
            log.error(dmsg('') + func_name() + '_FAILURE : ' + e.__str__())
            return create_result(result_=func_name() + '_FAILURE', more=e.__str__())

    @staticmethod
    def parse_report_to_stix(report_json: dict):
        try:
            return create_result(result_=func_name() + '_SUCCESS', items={'report': ReportParser(report_json).get_stix_report()} if report_json else {})
        except Exception as e:
            log.error(dmsg('') + func_name() + '_FAILURE : ' + e.__str__())
            return create_result(result_=func_name() + '_FAILURE', more=e.__str__())

    @staticmethod
    def get_all_tasks() -> dict:
        try:
            return create_result(result_=func_name() + '_SUCCESS', items={'tasks': get_all_data()})
        except Exception as e:
            log.error(dmsg('') + func_name() + '_FAILURE : ' + e.__str__())
            return create_result(result_=func_name() + '_FAILURE', more=e.__str__())

    def get_task(self, _net):
        try:
            _data = get_data_by_key(self.get_task_name(_net))
            return create_result(result_=func_name() + '_SUCCESS', items={'task': _data if _data else {}})
        except Exception as e:
            log.error(dmsg('') + func_name() + '_FAILURE : ' + e.__str__())
            return create_result(result_=func_name() + '_FAILURE', more=e.__str__())

    def get_task_progress(self, _net: str) -> dict:
        try:
            _data = get_data_by_key(self.get_task_name(_net))
            return create_result(result_=func_name() + '_SUCCESS', items={'processes': _data['processes'] if _data else {}})
        except Exception as e:
            log.error(dmsg('') + func_name() + '_FAILURE : ' + e.__str__())
            return create_result(result_=func_name() + '_FAILURE', more=e.__str__())

    # def is_task_running(self, ip: str):
    #     try:
    #         response = self.get_task(ip)
    #         if "SUCCESS" in response['result']:
    #             task = response['items']['task']['processes'] if response['items'] and response['items']['task'] and response['items']['task']['processes'] else {}
    #             if task.get('SYN Stealth Scan'):
    #                 status = task.get('SYN Stealth Scan').get('status')
    #                 if status == 'started':
    #                     return True
    #                 elif status == 'ended':
    #                     return False
    #             else:
    #                 log.error('SYN Scan has not started yet!')
    #                 return False
    #         else:
    #             log.error(f'Task for IP: {ip} does not exist!')
    #             return False
    #     except Exception as e:
    #         log.exception(dmsg('') + e.__str__())
    #         return False

    @staticmethod
    def get_all_reports():
        try:
            _temp = get_all_data()
            # print('get_all_reports line 202', _temp)
            all_keys = _temp[0] if _temp else []
            result = [rep for task_name, task in _temp[0].items() for rep_name, rep in task.get('reports').items() if (task.get('reports') and len(_temp) > 0)]
            return create_result(result_=func_name() + '_SUCCESS', items={'reports': result})
            # return {}
        except Exception as e:
            log.exception(dmsg('') + e.__str__())
            return create_result(result_=func_name() + '_FAILURE', more=e.__str__())

    def delete_task(self, _name: str):
        try:
            _result = delete_key(self.get_task_name(_name))
            if _result:
                return create_result(result_=func_name() + '_SUCCESS', status_code='200', more=f'Task with task name: {_name}, was successfully deleted')
            else:
                return create_result(result_=func_name() + '_FAILURE', status_code='500', more=f'Task with task name: {_name}, was NOT deleted')
        except Exception as e:
            log.error(dmsg('') + func_name() + '_FAILURE : ' + e.__str__())
            return create_result(result_=func_name() + '_FAILURE', more=e.__str__())

#
#
# v = Vaaas()
# t = v.get_all_reports()
# print(t)
# from report_parser.nmap_report_parser import ReportParser
#
# # v.is_task_running()
# v.scan_network(_name='test', _net='10.0.100.2', speed=4)
# r = v.get_task_reports(_net='10.0.100.2')
# reports = r['items']['reports']
# keyz = [key for key in reports.keys()]
# # print(keyz[0])
# print(ReportParser(reports[keyz[0]]).get_stix_report())
# # r = v.get_all_reports()
# with open(os.path.join(os.path.split(os.path.abspath(__file__))[0], 'report.json'), 'w') as f:
#     f.write('poutsa')
